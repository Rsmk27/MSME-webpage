<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sensors &amp; Interfaces — MSME Docs</title>
  <link rel="stylesheet" href="css/style.css" />
</head>
<body>

<header class="topbar">
  <button class="hamburger" id="hamburger" aria-label="Toggle menu">&#9776;</button>
  <a href="index.html" class="topbar-logo">
    <div class="logo-icon">M</div>
    <div>
      <span class="logo-text">MSME Docs</span>
      <span class="logo-sub">Embedded Systems Workshop</span>
    </div>
  </a>
  <div class="topbar-spacer"></div>
  <span class="topbar-badge">&#127979; Workshop</span>
</header>

<div class="overlay" id="overlay"></div>

<aside class="sidebar" id="sidebar">
  <nav>
    <div class="sidebar-section">
      <div class="sidebar-section-title">Navigation</div>
      <ul>
        <li><a href="index.html"><span class="nav-icon">&#127968;</span> Home</a></li>
      </ul>
    </div>
    <div class="sidebar-section">
      <div class="sidebar-section-title">Setup &amp; Tools</div>
      <ul>
        <li><a href="getting-started.html"><span class="nav-icon">&#128640;</span> Getting Started</a></li>
        <li><a href="hardware.html"><span class="nav-icon">&#9881;</span> Hardware Reference</a></li>
      </ul>
    </div>
    <div class="sidebar-section">
      <div class="sidebar-section-title">Programming</div>
      <ul>
        <li><a href="programming.html"><span class="nav-icon">&#128187;</span> STM32 Programming</a></li>
        <li><a href="sensors.html" class="active"><span class="nav-icon">&#128268;</span> Sensors &amp; Interfaces</a></li>
      </ul>
    </div>
    <div class="sidebar-section">
      <div class="sidebar-section-title">Advanced Topics</div>
      <ul>
        <li><a href="iot.html"><span class="nav-icon">&#127760;</span> IoT &amp; Cloud</a></li>
        <li><a href="linux.html"><span class="nav-icon">&#128032;</span> Linux Tools</a></li>
      </ul>
    </div>
    <div class="sidebar-section">
      <div class="sidebar-section-title">Workshop</div>
      <ul>
        <li><a href="workshop.html"><span class="nav-icon">&#128203;</span> Workshop Materials</a></li>
        <li><a href="projects.html"><span class="nav-icon">&#129302;</span> Projects</a></li>
      </ul>
    </div>
  </nav>
</aside>

<div class="main-wrapper">
  <main class="main-content">

    <div class="page-header">
      <div class="breadcrumb"><a href="index.html">Home</a> › Sensors &amp; Interfaces</div>
      <h1>&#128268; Sensors &amp; Interfaces</h1>
      <p>Interfacing the BME280 environmental sensor over I²C, and using the RFID-RC522 module with SPI on the STM32F446RE.</p>
    </div>

    <!-- BME280 -->
    <div class="content-section" id="bme280">
      <h2>&#127777; BME280 — Temperature, Humidity &amp; Pressure</h2>

      <p>The BME280 (Bosch) is a compact sensor that measures <strong>temperature</strong>, <strong>relative humidity</strong>, and <strong>barometric pressure</strong>. It supports both I²C and SPI. In this workshop we use I²C.</p>

      <h3>BME280 Specifications</h3>
      <table class="doc-table">
        <thead><tr><th>Parameter</th><th>Range</th><th>Resolution</th></tr></thead>
        <tbody>
          <tr><td>Temperature</td><td>−40 to +85 °C</td><td>0.01 °C</td></tr>
          <tr><td>Humidity</td><td>0 – 100 % RH</td><td>0.008 %</td></tr>
          <tr><td>Pressure</td><td>300 – 1100 hPa</td><td>0.18 Pa</td></tr>
          <tr><td>Supply Voltage</td><td>1.71 – 3.6 V</td><td>—</td></tr>
          <tr><td>I²C Address</td><td>0x76 (SDO low) or 0x77</td><td>—</td></tr>
          <tr><td>Interface</td><td>I²C / SPI</td><td>—</td></tr>
        </tbody>
      </table>

      <h3>Wiring — BME280 to NUCLEO-F446RE via I²C</h3>
      <table class="doc-table">
        <thead><tr><th>BME280 Pin</th><th>NUCLEO Pin</th><th>Function</th></tr></thead>
        <tbody>
          <tr><td>VCC</td><td>3.3 V (CN6 pin 4)</td><td>Power supply</td></tr>
          <tr><td>GND</td><td>GND</td><td>Ground</td></tr>
          <tr><td>SCL</td><td>PB8 (Arduino D15)</td><td>I²C1 Clock</td></tr>
          <tr><td>SDA</td><td>PB9 (Arduino D14)</td><td>I²C1 Data</td></tr>
          <tr><td>SDO</td><td>GND</td><td>I²C address = 0x76</td></tr>
          <tr><td>CSB</td><td>3.3 V</td><td>Select I²C mode</td></tr>
        </tbody>
      </table>

      <div class="callout warning">
        <span class="callout-icon">&#9888;</span>
        <span>The BME280 operates at 3.3 V. Do not connect it to the 5 V rail — this will damage the sensor.</span>
      </div>

      <h3>STM32CubeMX Configuration</h3>
      <ol class="step-list">
        <li>Open the <code>.ioc</code> file. Navigate to <em>Connectivity → I2C1</em>.</li>
        <li>Set I2C1 to <em>I2C</em> mode. This auto-assigns PB8 (SCL) and PB9 (SDA).</li>
        <li>Enable DMA or polling — for simplicity, use polling (<code>HAL_I2C_Master_Transmit</code> / <code>HAL_I2C_Mem_Read</code>).</li>
        <li>Generate code.</li>
      </ol>

      <h3>Reading Data (Polling)</h3>
      <div class="code-block"><pre><span class="pp">#define</span> BME280_ADDR  (<span class="num">0x76</span> &lt;&lt; <span class="num">1</span>)  <span class="cm">/* HAL uses 8-bit address */</span>
<span class="pp">#define</span> REG_TEMP_MSB  <span class="num">0xFA</span>

<span class="kw">uint8_t</span> raw[<span class="num">6</span>];

<span class="cm">/* Burst-read temperature, pressure, humidity raw bytes */</span>
<span class="fn">HAL_I2C_Mem_Read</span>(&amp;hi2c1, BME280_ADDR, <span class="num">0xF7</span>,
                 I2C_MEMADD_SIZE_8BIT, raw, <span class="num">6</span>, <span class="num">100</span>);

<span class="cm">/* Apply compensation formulas (from BME280 datasheet) */</span>
int32_t adc_T = ((int32_t)raw[<span class="num">3</span>] &lt;&lt; <span class="num">12</span>) |
               ((int32_t)raw[<span class="num">4</span>] &lt;&lt; <span class="num">4</span>)  |
               (raw[<span class="num">5</span>] &gt;&gt; <span class="num">4</span>);
<span class="cm">/* ... compensate using calibration data from 0x88-0xA1 */</span></pre></div>

      <div class="callout info">
        <span class="callout-icon">&#8505;</span>
        <span>The BME280 requires reading factory calibration data from registers 0x88–0x9F before applying the compensation formulas. Many open-source BME280 HAL drivers handle this automatically.</span>
      </div>
    </div>

    <!-- SPI & RFID -->
    <div class="content-section" id="rfid">
      <h2>&#128268; SPI Protocol &amp; RFID-RC522</h2>

      <p>SPI (Serial Peripheral Interface) is a synchronous full-duplex protocol widely used for high-speed peripherals. The RFID-RC522 module uses SPI to communicate with the MCU.</p>

      <h3>SPI Protocol Overview</h3>

      <img src="https://github.com/user-attachments/assets/1f5f865f-e78c-4754-9abd-9024cd06ee01"
           alt="SPI Master–Slave topology diagram" class="doc-image" />
      <p class="img-caption">SPI topology: one master with multiple slaves selected by individual CS (Chip Select) lines. Each slave shares SCLK, MOSI, and MISO.</p>

      <img src="https://github.com/user-attachments/assets/10b1919a-2866-4f22-9b1e-903676151403"
           alt="SPI timing diagram — Mode 1" class="doc-image" />
      <p class="img-caption">SPI timing diagram (Mode 1: CPOL=0, CPHA=1). Data is sampled on the falling edge and shifted on the rising edge.</p>

      <h3>SPI Signals</h3>
      <table class="doc-table">
        <thead><tr><th>Signal</th><th>Direction</th><th>Description</th></tr></thead>
        <tbody>
          <tr><td>SCLK</td><td>Master → Slave</td><td>Serial clock — synchronizes data transfer</td></tr>
          <tr><td>MOSI</td><td>Master → Slave</td><td>Master Out Slave In — data from MCU</td></tr>
          <tr><td>MISO</td><td>Slave → Master</td><td>Master In Slave Out — data from peripheral</td></tr>
          <tr><td>CS/NSS</td><td>Master → Slave</td><td>Chip Select — active-low, selects one slave</td></tr>
        </tbody>
      </table>

      <h3>SPI Modes</h3>
      <table class="doc-table">
        <thead><tr><th>Mode</th><th>CPOL</th><th>CPHA</th><th>Clock Idle</th><th>Sample Edge</th></tr></thead>
        <tbody>
          <tr><td>0</td><td>0</td><td>0</td><td>Low</td><td>Rising</td></tr>
          <tr><td>1</td><td>0</td><td>1</td><td>Low</td><td>Falling</td></tr>
          <tr><td>2</td><td>1</td><td>0</td><td>High</td><td>Falling</td></tr>
          <tr><td>3</td><td>1</td><td>1</td><td>High</td><td>Rising</td></tr>
        </tbody>
      </table>
      <p>The MFRC522 (RC522) uses <strong>SPI Mode 0</strong> (CPOL=0, CPHA=0).</p>

      <h3>RFID-RC522 Wiring to NUCLEO-F446RE</h3>
      <table class="doc-table">
        <thead><tr><th>RC522 Pin</th><th>NUCLEO Pin</th><th>Function</th></tr></thead>
        <tbody>
          <tr><td>VCC (3.3 V)</td><td>3.3 V</td><td>Power</td></tr>
          <tr><td>GND</td><td>GND</td><td>Ground</td></tr>
          <tr><td>SCK</td><td>PA5 / SPI1_SCK</td><td>SPI Clock</td></tr>
          <tr><td>MOSI</td><td>PA7 / SPI1_MOSI</td><td>Data to RC522</td></tr>
          <tr><td>MISO</td><td>PA6 / SPI1_MISO</td><td>Data from RC522</td></tr>
          <tr><td>SDA (CS)</td><td>PB6 (GPIO_Output)</td><td>Chip select</td></tr>
          <tr><td>RST</td><td>PB5 (GPIO_Output)</td><td>Hardware reset</td></tr>
          <tr><td>IRQ</td><td>— (optional)</td><td>Interrupt output</td></tr>
        </tbody>
      </table>

      <div class="callout warning">
        <span class="callout-icon">&#9888;</span>
        <span>The RC522 is a 3.3 V device. If your NUCLEO board outputs 5 V on some pins, use a level shifter to avoid damage.</span>
      </div>

      <h3>SPI1 Configuration in CubeMX</h3>
      <ol class="step-list">
        <li>Open the <code>.ioc</code> file → <em>Connectivity → SPI1</em>.</li>
        <li>Set mode to <em>Full-Duplex Master</em>.</li>
        <li>Data Size: 8-bit. First Bit: MSB. Baud Rate: ≤ 10 Mbps.</li>
        <li>Clock Polarity (CPOL): Low. Clock Phase (CPHA): 1 Edge (Mode 0).</li>
        <li>Set PB6 as GPIO_Output (NSS software). Generate code.</li>
      </ol>

      <h3>SPI Transmit/Receive Example</h3>
      <div class="code-block"><pre><span class="kw">void</span> <span class="fn">RFID_WriteRegister</span>(<span class="kw">uint8_t</span> addr, <span class="kw">uint8_t</span> val)
{
  <span class="fn">HAL_GPIO_WritePin</span>(GPIOB, GPIO_PIN_6, GPIO_PIN_RESET); <span class="cm">/* CS low */</span>
  <span class="kw">uint8_t</span> tx[<span class="num">2</span>] = { (addr &lt;&lt; <span class="num">1</span>) &amp; <span class="num">0x7E</span>, val };
  <span class="fn">HAL_SPI_Transmit</span>(&amp;hspi1, tx, <span class="num">2</span>, <span class="num">100</span>);
  <span class="fn">HAL_GPIO_WritePin</span>(GPIOB, GPIO_PIN_6, GPIO_PIN_SET);   <span class="cm">/* CS high */</span>
}

<span class="kw">uint8_t</span> <span class="fn">RFID_ReadRegister</span>(<span class="kw">uint8_t</span> addr)
{
  <span class="kw">uint8_t</span> tx = ((addr &lt;&lt; <span class="num">1</span>) &amp; <span class="num">0x7E</span>) | <span class="num">0x80</span>; <span class="cm">/* read bit */</span>
  <span class="kw">uint8_t</span> rx = <span class="num">0</span>;
  <span class="fn">HAL_GPIO_WritePin</span>(GPIOB, GPIO_PIN_6, GPIO_PIN_RESET);
  <span class="fn">HAL_SPI_TransmitReceive</span>(&amp;hspi1, &amp;tx, &amp;rx, <span class="num">1</span>, <span class="num">100</span>);
  <span class="fn">HAL_GPIO_WritePin</span>(GPIOB, GPIO_PIN_6, GPIO_PIN_SET);
  <span class="kw">return</span> rx;
}</pre></div>
    </div>

  </main>
  <footer class="site-footer">
    <p>&#169; 2024 MSME Embedded Systems &amp; IoT Workshop</p>
  </footer>
</div>

<script>
  const hamburger = document.getElementById('hamburger');
  const sidebar   = document.getElementById('sidebar');
  const overlay   = document.getElementById('overlay');
  hamburger.addEventListener('click', () => { sidebar.classList.toggle('open'); overlay.classList.toggle('active'); });
  overlay.addEventListener('click',   () => { sidebar.classList.remove('open'); overlay.classList.remove('active'); });
</script>
</body>
</html>
